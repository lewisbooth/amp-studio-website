<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Amp Studio Â» Online Marketing, Web Development, Branding, CGI &amp; Motion Graphics</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:200" rel="stylesheet">
    <link rel="shortcut icon" href="img/logos/amp-studio-favicon.png">
    <link rel="icon" href="img/logos/amp-studio-favicon.png">
  </head>
  <body>
    <canvas id="main-bg"></canvas>
    <div class="amp-logo">
      <div class="amp-logo-balls-container">
        <div class="amp-logo-ball"></div>
        <div class="amp-logo-ball"></div>
        <div class="amp-logo-ball"></div> 
        <div class="amp-logo-ball"></div> 
      </div>
      <img src="img/logos/amp-studio-main-white.svg" alt="Amp Studio Logo" class="amp-logo-main">
      <p>
        Digital Marketing
      </p>
      <p class="amp-logo-strapline">
        Preparing for launch
      </p>
      <a href="mailto:lewis@amp.studio">
        lewis@amp.studio
      </a>
    </div>

    <script>

      const config = {
        nodes: {
          // Number of nodes per 500px of canvas width
          density: 30,
          // Size and randomness in pixels
          size: 1,
          sizeVariation: 0.5,
          // Movement speed and randomness in pixels/sec
          speed: 0.5,
          speedVariation: 0.5,
          // How far away in pixels the nodes will link up
          linkLength: 200,
          // Link width in pixels
          linkWidth: 1,
          linkOpacity: 0.3
        },
        pulse: {
          // How wide the node links become when pulsed
          widthMultiplier: 3,
          // Duration in seconds before pulse fades
          duration: 2,
          // Speed of pulse in pixels per second
          speed: 500
        }
      }

      // Set up globals
      const canvas = document.querySelector('#main-bg');
      const c = canvas.getContext('2d');
      let winX = window.innerWidth;
      let winY = window.innerHeight;
      const nodes = [];

      // Initialise the canvas
      window.onload = () => { 
        resizeCanvas()
        setInterval(function() { window.requestAnimationFrame(stepCanvas) }, 1000/60); 
      };
      
      window.onresize = () => { resizeCanvas() };

      const getRandom = (min, max) => {
        return Math.random() * (max - min) + min;
      }

      const addNodes = (int = 1) => {
          for (i = 0; i < int; i++) {
            let xPos     =  getRandom(1, winX);
            let yPos     =  getRandom(1, winY);
            let xVector  =  getRandom(-config.nodes.speed, config.nodes.speed) + 
                            getRandom(-config.nodes.speedVariation, config.nodes.speedVariation); 
            let yVector  =  getRandom(-config.nodes.speed, config.nodes.speed) + 
                            getRandom(-config.nodes.speedVariation, config.nodes.speedVariation); 
            let nodeSize =  getRandom(-config.nodes.sizeVariation, config.nodes.sizeVariation) + config.nodes.size;
            // X position, Y position, X vector, Y vector, Node size, Pulse strength
            let node = [xPos, yPos, xVector, yVector, nodeSize, 1];
            nodes.push(node);
          }
      }

      const resizeCanvas = () => {
        // Save last size so we can calculate the change and adjust the nodes
        let oldWinX = winX;
        let oldWinY = winY;
        // Store new size
        winX = window.innerWidth;
        winY = window.innerHeight;
        // Calculate the change as a multiplier
        let winXDelta = winX / oldWinX;
        let winYDelta = winY / oldWinY;
        // Adjust each node's position based on new dimensions, so none leave the window
        nodes.forEach((node) => {
          node[0] *= winXDelta;
          node[1] *= winYDelta;
        });
        // Add or remove nodes to maintain desired density
        let desiredNodes = getNodeQuantity();
        if (desiredNodes > nodes.length) {
          addNodes(desiredNodes - nodes.length)
        } else if (desiredNodes < nodes.length) {
          nodes.splice(desiredNodes - 1)
        }
        // Finally resize the canvas
        c.canvas.width = winX;
        c.canvas.height = winY;
      }

      const getNodeQuantity = () => {
        return Math.floor(winX / 500 * config.nodes.density);
      }

      const stepCanvas = () => {

        // Move the nodes based on vectors
        nodes.forEach((node) => {
          // Check if the node should bounce off the canvas edge, if so flip the vector
          if (node[0] + node[2] < 0 || node[0] + node[2] > winX) {
            node[2] = -node[2];
          }
          if (node[1] + node[3] < 0 || node[1] + node[3] > winY) {
            node[3] = -node[3];
          }
          node[0] += node[2];
          node[1] += node[3];
        });
        // Clear the canvas before redraw
        c.clearRect(0, 0, canvas.width, canvas.height);
        // Draw the nodes & connections
        nodes.forEach((node) => {
          c.beginPath();
          c.arc(node[0], node[1], node[4], 0, 360);
          c.fillStyle = "rgba(225,225,225,0.3)"
          c.strokeStyle = "rgba(225,225,225,0.3)"
          c.fill();
          c.stroke();

          // Search for other close nodes and connect with a line
          nodes.forEach((otherNode) => {
            // Find distance with Pythagoras' Theorem 
            let xDelta = Math.abs(node[0] - otherNode[0]);
            let yDelta = Math.abs(node[1] - otherNode[1]);
            let distance = Math.sqrt(xDelta ** 2 + yDelta ** 2);

            // Link close nodes
            if (distance < config.nodes.linkLength) {
              c.beginPath();
              c.moveTo(node[0], node[1]);
              c.lineTo(otherNode[0], otherNode[1]);
              // Links become stronger besed on distance
              let opacity = config.nodes.linkOpacity - config.nodes.linkOpacity / config.nodes.linkLength * distance;
              c.strokeStyle = 'rgba(225,225,225,' + opacity;
              c.stroke();
            }
          });

        });
      }

    </script>

  </body>
</html>