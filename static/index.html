<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Amp Studio Â» Online Marketing, Web Development, Branding, CGI &amp; Motion Graphics</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:200" rel="stylesheet">
    <link rel="shortcut icon" href="img/logos/amp-studio-favicon.png">
    <link rel="icon" href="img/logos/amp-studio-favicon.png">
  </head>
  <body>
    <canvas id="main-bg"></canvas>
    <div class="amp-logo">
      <div class="amp-logo-balls-container">
        <div class="amp-logo-ball"></div>
        <div class="amp-logo-ball"></div>
        <div class="amp-logo-ball"></div> 
        <div class="amp-logo-ball"></div> 
      </div>
      <img src="img/logos/amp-studio-main-white.svg" alt="Amp Studio Logo" class="amp-logo-main">
      <p class="amp-logo-strapline">
        Coming Soon
      </p>
      <p>
        <a href="mailto:lewis@amp.studio">
          lewis@amp.studio
        </a>
      </p>
    </div>

    <script>

      const config = {
        nodes: {
          quantity: 70,
          size: 1,
          sizeVariation: 0.5,
          // Movement speed and randomness in pixels/sec
          speed: 0.5,
          speedVariation: 0.5,
          // How far away in pixels the nodes will link up
          linkLength: 200,
          // Link width in pixels
          linkWidth: 1,
          linkOpacity: 0.5
        },
        pulse: {
          // How wide the node links become when pulsed
          widthMultiplier: 3,
          // Duration in seconds before pulse fades
          duration: 2,
          // Speed of pulse in pixels per second
          speed: 500
        }
      }

      const canvas = document.querySelector('#main-bg');
      const c = canvas.getContext('2d');
      let winX = window.innerWidth;
      let winY = window.innerHeight;
      const nodes = [];

      window.onload = () => { 
        initializeCanvas()
        setInterval(function() { window.requestAnimationFrame(stepCanvas) }, 1000/60); 
      };
      
      window.onresize = () => { resizeCanvas() };

      function getRandom(min, max) {
        return Math.random() * (max - min) + min;
      }

      function resizeCanvas() {
        winX = window.innerWidth;
        winY = window.innerHeight;
        c.canvas.width = winX;
        c.canvas.height = winY;
      }

      function initializeCanvas() {
        resizeCanvas();
        for (i = 0; i < config.nodes.quantity; i++) {
          let xPos = getRandom(1, winX);
          let yPos = getRandom(1, winY);
          let xVector = getRandom(-config.nodes.speed, config.nodes.speed) + 
                        getRandom(-config.nodes.speedVariation, config.nodes.speedVariation); 
          let yVector = getRandom(-config.nodes.speed, config.nodes.speed) + 
                        getRandom(-config.nodes.speedVariation, config.nodes.speedVariation); 
          let nodeSize = getRandom(-config.nodes.sizeVariation, config.nodes.sizeVariation) + config.nodes.size;
          // X position, Y position, X vector, Y vector, Node size, Link width initial multiplier (for pulsing)
          let node = [xPos, yPos, xVector, yVector, nodeSize];
          nodes.push(node);
        }
        console.log(nodes)
      }

      function stepCanvas() {

        nodes.forEach((node) => {
          // Check if the node has left the canvas, if so flip the vector
          if (node[0] + node[2] < 0 || node[0] + node[2] > winX) {
            node[2] = -node[2];
          }
          if (node[1] + node[3] < 0 || node[1] + node[3] > winY) {
            node[3] = -node[3];
          }
          node[0] += node[2];
          node[1] += node[3];
        });

        c.clearRect(0, 0, canvas.width, canvas.height);
        // Draw the nodes & connections
        nodes.forEach((node) => {
          c.beginPath();
          c.arc(node[0], node[1], node[4], 0, 360);
          c.fillStyle = "#ffffff"
          c.strokeStyle = "#ffffff"
          c.fill();
          c.stroke();

          // Search for other close nodes and connect with a line
          nodes.forEach((otherNode) => {
            // Find distance with Pythagoras' Theorem 
            let xDelta = Math.abs(node[0] - otherNode[0]);
            let yDelta = Math.abs(node[1] - otherNode[1]);
            let distance = Math.sqrt(xDelta ** 2 + yDelta ** 2);

            // Link close nodes
            if (distance < config.nodes.linkLength) {
              c.beginPath();
              c.moveTo(node[0], node[1]);
              c.lineTo(otherNode[0], otherNode[1]);
              // Links become stronger besed on distance
              let opacity = config.nodes.linkOpacity - config.nodes.linkOpacity / config.nodes.linkLength * distance;
              c.strokeStyle = `rgba(225,225,225,${opacity}`;
              c.stroke();
            }
          });

        });
      }

    </script>

  </body>
</html>